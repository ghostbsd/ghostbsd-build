#!/rescue/sh

set -e

PATH="/rescue"

# Enhanced logging function
log() {
    echo "$(date '+%H:%M:%S') [INIT] $*"
}

error_exit() {
    log "ERROR: $*"
    exit 1
}

if [ "$(ps -o command 1 | tail -n 1 | ( read -r c o; echo "${o}" ))" = "-s" ]; then
    log "Running in single-user mode"
    SINGLE_USER="true"
fi

log "=== GhostBSD Live System Initialization ==="

log "Remount rootfs as read-write"
mount -u -w /

makedir=${makedir:-"/cdrom"}

log "Make mountpoints /cdrom"
mkdir -p "${makedir}"

log "Waiting for GhostBSD media to initialize"
timeout=60
while [ $timeout -gt 0 ]; do
    if [ -e "/dev/iso9660/GHOSTBSD" ]; then
        log "Found /dev/iso9660/GHOSTBSD"
        sleep 2
        break
    fi
    sleep 2
    timeout=$((timeout - 1))
done

if [ $timeout -eq 0 ]; then
    error_exit "Timeout waiting for GhostBSD media"
fi

log "Mount cdrom"
if ! mount_cd9660 /dev/iso9660/@VOLUME@ /cdrom; then
    error_exit "Failed to mount cdrom"
fi

if [ "$SINGLE_USER" = "true" ]; then
    log "Starting interactive shell in temporary rootfs ..."
    exit 0
fi

# Enhanced memory checks and system analysis for 8GB minimum
log "=== System Analysis ==="
requiredmem=8589934592  # 8GB minimum (updated requirement for GhostBSD)
realmem=$(sysctl -n hw.realmem)
realmem_gb=$((realmem/1024/1024/1024))
log "Required memory: $requiredmem bytes (8GB minimum)"
log "Detected memory: $realmem bytes (${realmem_gb}GB)"

if [ "$realmem" -lt "$requiredmem" ]; then
    SINGLE_USER="true"
    error_exit "GhostBSD requires 8GB of memory for operation. Detected: ${realmem_gb}GB. Please use a system with at least 8GB RAM."
fi

# Calculate memdisk size based on available memory (optimized for 8GB minimum)
if [ $realmem_gb -ge 32 ]; then
    # Very high memory systems: use 80%
    memdisk_size=$((("${realmem}"*80/100)/1024/1024/1024))
    log "Calculated memdisk size: ${memdisk_size}GB (80% of ${realmem_gb}GB - very high memory system)"
elif [ $realmem_gb -ge 24 ]; then
    # High memory systems: use 78%
    memdisk_size=$((("${realmem}"*78/100)/1024/1024/1024))
    log "Calculated memdisk size: ${memdisk_size}GB (78% of ${realmem_gb}GB - high memory system)"
elif [ $realmem_gb -ge 16 ]; then
    # 16-24GB systems: use 75%
    memdisk_size=$((("${realmem}"*75/100)/1024/1024/1024))
    log "Calculated memdisk size: ${memdisk_size}GB (75% of ${realmem_gb}GB - high memory system)"
elif [ $realmem_gb -ge 12 ]; then
    # 12-16GB systems: use 72% 
    memdisk_size=$((("${realmem}"*72/100)/1024/1024/1024))
    log "Calculated memdisk size: ${memdisk_size}GB (72% of ${realmem_gb}GB - medium-high memory system)"
else
    # 8-12GB systems: use 70% (conservative for 8GB minimum)
    memdisk_size=$((("${realmem}"*70/100)/1024/1024/1024))
    log "Calculated memdisk size: ${memdisk_size}GB (70% of ${realmem_gb}GB - 8GB minimum system)"
fi

free_mem_gb=$(((realmem - (memdisk_size * 1024 * 1024 * 1024))/1024/1024/1024))
log "Free memory after memdisk allocation: ${free_mem_gb}GB"

# Additional safety check for 8GB systems
if [ $free_mem_gb -lt 2 ]; then
    log "WARNING: Less than 2GB free memory remaining after memdisk allocation"
    log "System may experience performance issues"
    # For 8GB systems, we might need to be more conservative
    if [ $realmem_gb -le 10 ]; then
        log "Adjusting memdisk size for better performance on 8GB system..."
        memdisk_size=$((("${realmem}"*65/100)/1024/1024/1024))
        free_mem_gb=$(((realmem - (memdisk_size * 1024 * 1024 * 1024))/1024/1024/1024))
        log "Adjusted memdisk size: ${memdisk_size}GB (65% of ${realmem_gb}GB)"
        log "Adjusted free memory: ${free_mem_gb}GB"
    fi
fi

# Enhanced system image analysis with compression detection
log "=== System Image Analysis with Compression Detection ==="

# Detect compression type
compression_type="none"
system_img_path=""

if [ -f /cdrom/data/compression.txt ]; then
    compression_type=$(cat /cdrom/data/compression.txt)
    log "Detected compression type from metadata: ${compression_type}"
else
    log "No compression metadata found, detecting from filenames..."
fi

# Determine system image path and compression type
if [ -f /cdrom/data/system.img.gz ]; then
    compression_type="gzip"
    system_img_path="/cdrom/data/system.img.gz"
    log "Found compressed system image: system.img.gz"
elif [ -f /cdrom/data/system.img ]; then
    compression_type="none"
    system_img_path="/cdrom/data/system.img"
    log "Found uncompressed system image: system.img"
else
    error_exit "No system image found (looked for system.img.gz and system.img)"
fi

log "Using compression type: ${compression_type}"
log "System image path: ${system_img_path}"

img_size=$(stat -f %z "${system_img_path}")
img_size_mb=$((img_size / 1024 / 1024))
log "System image size: ${img_size_mb}MB (${compression_type})"

# Comprehensive image validation
if [ $img_size_mb -lt 50 ]; then
    error_exit "System image appears truncated (${img_size_mb}MB is too small)"
fi

# For compressed images, estimate decompressed size (assume ~2.5:1 compression ratio)
if [ "$compression_type" = "gzip" ]; then
    estimated_decompressed_mb=$((img_size_mb * 25 / 10))
    log "Estimated decompressed size: ~${estimated_decompressed_mb}MB"
    
    # Check if we have enough memory for the decompressed image
    memdisk_size_mb=$((memdisk_size * 1024))
    if [ $estimated_decompressed_mb -gt $((memdisk_size_mb * 95 / 100)) ]; then
        log "WARNING: Estimated decompressed image (~${estimated_decompressed_mb}MB) is close to memdisk limit (${memdisk_size_mb}MB)"
    fi
else
    # Check if we have enough memory for the uncompressed image
    memdisk_size_mb=$((memdisk_size * 1024))
    if [ $img_size_mb -gt $((memdisk_size_mb * 95 / 100)) ]; then
        log "WARNING: System image (${img_size_mb}MB) is close to memdisk limit (${memdisk_size_mb}MB)"
    fi
fi

# Basic image format validation for compressed files
if [ "$compression_type" = "gzip" ]; then
    log "Validating gzip file format..."
    if ! gzip -t "${system_img_path}" 2>/dev/null; then
        error_exit "System image is not a valid gzip file"
    fi
    log "Gzip file validation passed"
fi

log "Mount swap-based memdisk"
if ! mdconfig -a -t swap -s ${memdisk_size}g -u 1 >/dev/null 2>/dev/null; then
    error_exit "Failed to create memory disk"
fi

# Create ZFS pool with enhanced error handling and settings optimized for GhostBSD
log "=== ZFS Pool Creation ==="
pool_creation_attempts=0
max_attempts=3

while [ $pool_creation_attempts -lt $max_attempts ]; do
    pool_creation_attempts=$((pool_creation_attempts + 1))
    log "Creating ZFS pool 'livecd' (attempt ${pool_creation_attempts}/${max_attempts})"
    
    # Start with compatible settings for GhostBSD
    if zpool create -O compression=off -O primarycache=all livecd /dev/md1 >/dev/null 2>/dev/null; then
        log "ZFS pool created successfully"
        break
    else
        log "Pool creation attempt ${pool_creation_attempts} failed"
        if [ $pool_creation_attempts -eq $max_attempts ]; then
            # Cleanup on final failure
            mdconfig -d -u 1 >/dev/null 2>/dev/null || true
            error_exit "Failed to create ZFS pool after ${max_attempts} attempts"
        fi
        
        # Cleanup for retry
        zpool destroy livecd >/dev/null 2>/dev/null || true
        sleep 2
    fi
done

# Verify pool is healthy
log "Verifying ZFS pool status"
if ! zpool status livecd >/dev/null 2>&1; then
    error_exit "ZFS pool 'livecd' is not available after creation"
fi

log "Pool information:"
zpool list livecd
zpool status livecd

# Enhanced system image loading with gzip decompression support
log "=== System Image Loading with Compression Support ==="
receive_success=false
receive_method=""

# Start background monitoring
log "Starting receive monitoring..."
(
    prev_size=0
    stall_count=0
    while true; do
        sleep 10
        if zfs list livecd >/dev/null 2>&1; then
            current_used=$(zfs list -H -o used livecd 2>/dev/null | tr -d 'KMGT' | head -c -1 2>/dev/null || echo 0)
            if [ "$current_used" != "$prev_size" ]; then
                log "Receive progress: ${current_used} used"
                prev_size="$current_used"
                stall_count=0
            else
                stall_count=$((stall_count + 1))
                if [ $stall_count -gt 12 ]; then  # 2 minutes of no progress
                    log "WARNING: Receive appears stalled for 2+ minutes"
                fi
            fi
        fi
        
        # Check if receive process is still running
        if ! pgrep -f "zfs recv\|gzip\|zcat\|dd.*system.img" >/dev/null 2>&1; then
            break
        fi
    done
) &
MONITOR_PID=$!

# Method 1: Direct streaming receive with decompression
log "Attempting direct streaming receive with ${compression_type} decompression"

case "$compression_type" in
    "gzip")
        if zcat "${system_img_path}" 2>/tmp/gzip1.log | zfs recv livecd 2>/tmp/zfs_recv1.log; then
            log "Gzip decompression + receive completed successfully"
            receive_success=true
            receive_method="gzip_stream"
        else
            log "Gzip streaming failed"
            [ -f /tmp/gzip1.log ] && log "Gzip log:" && cat /tmp/gzip1.log
            [ -f /tmp/zfs_recv1.log ] && log "ZFS recv log:" && cat /tmp/zfs_recv1.log
        fi
        ;;
    "none")
        if dd if="${system_img_path}" bs=1M 2>/tmp/dd1.log | zfs recv livecd 2>/tmp/zfs_recv1.log; then
            log "Uncompressed direct streaming receive completed successfully"
            receive_success=true
            receive_method="direct_stream"
        else
            log "Direct streaming receive failed"
            [ -f /tmp/dd1.log ] && log "DD log:" && cat /tmp/dd1.log
            [ -f /tmp/zfs_recv1.log ] && log "ZFS recv log:" && cat /tmp/zfs_recv1.log
        fi
        ;;
esac

# Method 2: Fallback with forced receive if direct streaming fails
if [ "$receive_success" != "true" ]; then
    log "Direct streaming failed, trying forced receive methods..."
    
    case "$compression_type" in
        "gzip")
            if zcat "${system_img_path}" 2>/tmp/gzip2.log | zfs recv -F livecd 2>/tmp/zfs_recv2.log; then
                log "Gzip forced receive completed successfully"
                receive_success=true
                receive_method="gzip_forced"
            else
                log "Gzip forced receive failed"
                [ -f /tmp/gzip2.log ] && log "Gzip error log:" && cat /tmp/gzip2.log
                [ -f /tmp/zfs_recv2.log ] && log "ZFS recv error log:" && cat /tmp/zfs_recv2.log
            fi
            ;;
        "none")
            if dd if="${system_img_path}" bs=64k 2>/tmp/dd2.log | zfs recv -F livecd 2>/tmp/zfs_recv2.log; then
                log "Uncompressed forced receive completed successfully"
                receive_success=true
                receive_method="direct_forced"
            else
                log "Uncompressed forced receive failed"
                [ -f /tmp/dd2.log ] && log "DD error log:" && cat /tmp/dd2.log
                [ -f /tmp/zfs_recv2.log ] && log "ZFS recv error log:" && cat /tmp/zfs_recv2.log
            fi
            ;;
    esac
fi

# Method 3: Last resort - decompress to memory first if streaming fails
if [ "$receive_success" != "true" ] && [ "$compression_type" = "gzip" ]; then
    log "All streaming methods failed, attempting decompress-to-memory approach..."
    
    # Check available space in /tmp
    tmp_avail=$(df /tmp | tail -1 | awk '{print $4}')
    tmp_avail_mb=$((tmp_avail / 1024))
    
    if [ $tmp_avail_mb -gt $((estimated_decompressed_mb + 100)) ]; then
        log "Decompressing to /tmp/system.img (estimated ${estimated_decompressed_mb}MB)"
        
        if zcat "${system_img_path}" > /tmp/system.img 2>/tmp/decompress.log; then
            log "Decompression completed, attempting receive"
            actual_size=$(stat -f %z /tmp/system.img)
            actual_size_mb=$((actual_size / 1024 / 1024))
            log "Actual decompressed size: ${actual_size_mb}MB"
            
            if zfs recv -F livecd < /tmp/system.img 2>/tmp/zfs_recv3.log; then
                log "Decompress-then-receive completed successfully"
                receive_success=true
                receive_method="decompress_then_receive"
            else
                log "Decompress-then-receive failed:"
                cat /tmp/zfs_recv3.log
            fi
            rm -f /tmp/system.img
        else
            log "Decompression to memory failed:"
            cat /tmp/decompress.log
        fi
    else
        log "Insufficient space in /tmp for decompression (need ~${estimated_decompressed_mb}MB, have ${tmp_avail_mb}MB)"
    fi
fi

# Stop monitoring
kill $MONITOR_PID 2>/dev/null || true

# Check final result
if [ "$receive_success" != "true" ]; then
    log "=== Receive Failure Analysis ==="
    log "All receive methods failed with compression type: ${compression_type}"
    log "System image path: ${system_img_path}"
    log "Available decompression tools:"
    which gzip 2>/dev/null && log "gzip: available" || log "gzip: NOT available"
    which zcat 2>/dev/null && log "zcat: available" || log "zcat: NOT available"
    log "Pool status:"
    zpool status livecd
    log "Available memory:"
    sysctl hw.realmem hw.physmem
    log "System image info:"
    ls -la "${system_img_path}"
    log "Available space:"
    df -h /tmp
    error_exit "Failed to load system image using any decompression method"
fi

log "System image loaded successfully using method: $receive_method with compression: $compression_type"

# Post-receive configuration optimized for GhostBSD
log "=== Post-Receive Configuration ==="

# Set optimal compression and settings now that receive is complete
log "Configuring received filesystem"
zfs set compression=zstd-9 livecd 2>/dev/null || log "Warning: Could not set compression"
zfs set primarycache=all livecd 2>/dev/null || log "Warning: Could not set primary cache"

# GhostBSD-specific optimizations
zfs set atime=off livecd 2>/dev/null || log "Warning: Could not disable atime"

# Verify the received filesystem
log "Verifying received filesystem"
if ! zfs list livecd >/dev/null 2>&1; then
    error_exit "Received filesystem verification failed"
fi

# Check if essential directories exist (GhostBSD specific)
if ! zfs mount livecd 2>/dev/null; then
    log "Warning: Could not explicitly mount livecd"
fi

# Verify essential GhostBSD components are present
essential_dirs="/bin /usr /etc /home"
for dir in $essential_dirs; do
    if [ ! -d "${dir}" ]; then
        log "WARNING: Essential directory ${dir} not found in live system"
    fi
done

# Display final status
log "=== System Load Complete ==="
zfs list livecd
log "Final pool status:"
zpool status livecd

# Optional: Display some ARC statistics if available
arc_size=$(sysctl -n kstat.zfs.misc.arcstats.size 2>/dev/null || echo "unknown")
if [ "$arc_size" != "unknown" ]; then
    arc_size_mb=$((arc_size / 1024 / 1024))
    log "ZFS ARC size: ${arc_size_mb}MB"
fi

# Set environment for reroot
log "Setting environment for reroot"
kenv init_shell="/rescue/sh"
kenv vfs.root.mountfrom="zfs:livecd"

log "=== Initialization completed successfully ==="
log "Method used: $receive_method"
log "Compression: $compression_type"
log "Memory: ${realmem_gb}GB total, ${memdisk_size}GB memdisk, ${free_mem_gb}GB free"
log "System image: ${img_size_mb}MB loaded successfully"
log "Ready to boot GhostBSD live system"

exit 0
